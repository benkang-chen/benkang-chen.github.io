[{"title":"语音识别NAR模型-Paraformer","path":"/2023/11/02/语音识别NAR模型-Paraformer/","content":"语音识别NAR模型-Paraformer1. 官方论文解读近年来，随着端到端语音识别的流行，基于 Transformer 结构的语音识别系统逐渐成为了主流。然而，由于 Transformer 是一种自回归模型，需要逐个生成目标文字，计算复杂度随着目标文字数量而呈线性增加，限制了其在工业生产中的应用。 针对 Transoformer 模型自回归生成文字的低计算效率的缺陷，学术界提出了非自回归模型来并行地输出目标文字（如图1所示）。根据生成目标文字时的迭代轮数，非自回归模型分为：多轮迭代式与单轮非自回归模型。 自回归模型与非自回归模型生成文字过程 迭代式非自回归模型，主要为 Mask-Predict 模式，训练时，将输入文字随机掩码，通过周边信息预测当前文字。解码时，采用多轮迭代的方式逐步生成目标文字；计算复杂度与迭代轮数有关（通常小于目标文字个数），相比于自回归模型，计算复杂度有所下降，但是解码需要多轮迭代的特性，限制了其在工业生产中的应用。相比于多轮迭代模型，单轮非自回归模型有着更加广阔的应用前景，可以通过单次解码获取全部目标文字，计算复杂度与目标文字个数无关，进而极大的提高了解码效率。然而，由于条件独立假设，单轮非自回归模型识别效果与自回归模型有着巨大的差距，特别是在工业大数据上。对于单轮非自回归模型，现有工作往往聚焦于如何更加准确的预测目标文字个数，如较为典型的 Mask CTC，采用 CTC 预测输出文字个数，尽管如此，考虑到现实应用中，语速、口音、静音以及噪声等因素的影响，如何准确的预测目标文字个数以及抽取目标文字对应的声学隐变量仍然是一个比较大的挑战。 另外一方面，我们通过对比自回归模型与单轮非自回归模型在工业大数据上的错误类型（如图2所示，AR 与 vanilla NAR），发现相比于自回归模型，非自回归模型在预测目标文字个数（插入错误+删除错误）方面差距较小，但是替换错误显著的增加，我们认为这是由于单轮非自回归模型中条件独立假设导致的语义信息丢失。 与此同时，目前非自回归模型主要停留在学术验证阶段，还没有工业大数据上的相关实验与结论。 在2万小时工业数据上自回归与非自回归模型错误类型统计 为了解决上述问题，我们设计了一种具有高识别率与计算效率的单轮非自回归模型Paraformer。 针对第一个问题，我们采用一个预测器（Predictor）来预测文字个数并通过 Continuous integrate-and-fire (CIF) [4]机制来抽取文字对应的声学隐变量。 针对第二个问题，受启发于机器翻译领域中的 Glancing language model（GLM）[5]，我们设计了一个基于 GLM 的 Sampler 模块来增强模型对上下文语义的建模。除此之外，我们还设计了一种生成负样本策略来引入 MWER[6] 区分性训练。 具体模型结构如图3所示，由 Encoder、Predictor、Sampler、Decoder 与 Loss function 几部分组成。Encoder 与自回归模型保持一致，可以为 Self-attention、SAN-M 或者 Conformer 结构。Predictor 为2层 DNN 模型，预测目标文字个数以及抽取目标文字对应的声学向量。Sampler 为无可学习参数模块，依据输入的声学向量和目标向量，生产含有语义的特征向量。Decoder 结构与自回归模型类似，为双向建模（自回归为单向建模）。Loss function 部分，除了交叉熵（CE）与 MWER 区分性优化目标，还包括了 Predictor 优化目标 MAE。 Paraformer模型结构图 其核心点主要有： Predictor 模块：基于 CIF 的 Predictor 来预测语音中目标文字个数以及抽取目标文字对应的声学特征向量 Sampler：通过采样，将声学特征向量与目标文字向量变换成含有语义信息的特征向量，配合双向的 Decoder 来增强模型对于上下文的建模能力 基于负样本采样的 MWER 训练准则 2. 各模块的理解整体流程假设输入(X,Y), X表示语音，有T帧， Y表示文字，有N个文字。Encoder把输入X映射到隐藏表示H。 然后Predictor把隐藏表示映射为预测的文字个数N’和对应的声学向量embedding Ea。输入Ea和H给Decoder，产生最后的预测Y’，这是第一次解码，主要为了得到预测的结果并通过Sampler模块来采样，这时梯度并不回传（其实代码里是可选择的）。Sampler采样Ea 和目标Ec来产生Es，需要依据Y’和Y之间的距离。Decoder最后使用Es和H来预测最终的结果Y’’，这时才会回传梯度。最后，Y’’用来采样负例并计算MWER, 通过目标长度N和预测的N’来计算MAE。 推断时，Sampler模块可以去掉，只使用和H来预测Y’，从而推理时并没有增加而外计算量。 Predictor 模块非自回归模型的一个核心问题是如何预测模型中 Decoder 需要输出的文字数目，以及如何为 Decoder 提供输入特征向量。之前关于非自回归的工作主要是采用 CTC 来进行预测字符数目以及输入向量。Paraformer 里我们采用基于2层 DNN 的 Predictor 网络。输出为0～1之间的浮点数，输出值累加来预测目标文字个数，通过 CIF 机制抽取声学特征向量（图4为CIF过程示例）。训练过程中采用 MAE 来监督 Predictor 模块学习。 CIF过程示例 详细的CIF理解参考：https://blog.csdn.net/zwr198/article/details/127938332 Sampler模块非自回归模型的另一个核心问题是如何增强模型对上下文建模能力，现有的通用的单轮自回归模型 (vanilla-NAR) 为了高效计算效率，模型中 decoder 去除了显式的 Dependency 建模，从而在处理同音替换错误的能力会弱很多。从图2也可以看出 vanilla-NAR 相比于自回归（AR）的端到端语音识别系统在替换错误（substitution）上会明显增多。针对这个问题，Paraformer 借鉴来机器翻译里 GLM 工作，通过 Samper 模块来增强 Decoder 对于预测目标文字内在的 Dependency 的建模。Sampler 模块在解码时不工作，因此不会影响模型推理效率。数学模型如下： glm GLM采样的原理理解来自论文字节跳动Glancing Transformer，详细解读参考：https://mp.weixin.qq.com/s/RuKc9gS26-kCUpifQ-xNYg 参考的资料：https://zhuanlan.zhihu.com/p/649558283 https://zhuanlan.zhihu.com/p/89209220","tags":["ASR"],"categories":["语音识别"]},{"title":"机器学习中的评价指标","path":"/2022/09/23/机器学习中的评价指标/","content":"机器学习中的评价指标1 .分类评价指标先通过一个二分类的例子来理解准确率、召回率、F1值如何计算的。 1.1 二分类任务例如，一个二分类任务，其中标签0表示positive，标签1表示negative。现有如下所示的标签值与预测值： y_true = [1, 0, 0, 0, 1, 1, 0, 0, 0, 0] y_pred = [1, 1, 1, 1, 1, 0, 0, 0, 0, 1] 1.1.1 混淆矩阵真实\\预测PNP TPFNNFPTN 二分类的混淆矩阵的格式如上表，如何理解这个混淆矩阵呢？首先横着看，然后纵向看，例如TP，横向表示真实的正样本，纵向表示预测的正样本，因此TP就表示将正样本预测为正样本，即预测正确。因此有： True Positive(TP)：表示将正样本预测为正样本，也就是正确的正样本，即预测正确。 False Negative(FN): 表示将正样本预测为负样本，也就是错误的负样本，即预测错误。 False Positive(FP): 表示将负样本预测为正样本，也就是错误的负样本，即预测错误。 True Negative(TN): 表示将负样本预测为负样本，也就是正确的负样本，即预测正确。 因此上述的二分类的例子的混淆矩阵如下： 真实\\预测010 34112 1.1.2 指标定义$$accracury &#x3D; \\frac {TP+FP} {TP+FN+FP+TN}$$ $$precision &#x3D; \\frac {TP}{TP+FP}$$ $$recall &#x3D; \\frac{TP}{TP+FN}$$ $$F -score &#x3D; (1 + \\beta^2)\\frac{precision \\dot recall}{\\beta^2 \\dot precision + recall}$$ 当$$F-score$$中 $$\\beta &#x3D; 1$$时为 $$F_1$$值， $$F_1$$值是最常用的。 准确率是最好理解的，所有预测对的值除以样本的总数。精确率是指预测对的正样本在整个预测为正样本中的比例，召回率指的是预测对的正样本占整个真实正样本的中的比例。因此，召回率越高说明模型寻找正样本的能力越强， $$F_{score}$$是精确率与召回率的调和平均。通常在具体的实施中，不会明确哪一个样本是正样本，哪一个样本是负样本，对于某个类别都可以计算其各项指标，但是准确率只有一个。 上述例子中准确率为： $$accuracy &#x3D; \\frac{3+2}{3+4+1+2} &#x3D;0.5$$ 对于样本0： $$precision &#x3D; \\frac{3}{3+1}&#x3D;0.75$$ $$recall &#x3D; \\frac{3}{3+4} &#x3D; 0.43$$ $$F_1 &#x3D; \\frac{2 \\times 0.75\\times0.43}{0.75+0.43}&#x3D;0.55$$ 对于样本1来说： $$precision &#x3D; \\frac{2}{2+4}&#x3D;0.33$$ $$recall &#x3D; \\frac{2}{2+1} &#x3D; 0.67$$ $$F_1 &#x3D; \\frac{2\\times0.33\\times0.67}{0.33+0.67}&#x3D;0.44$$ 如何衡量整体的精确率、召回率、 $$F_1$$值呢，常用的方法有两种：算术平均与加权平均。 算术平均 所谓算术平均就是等权重的对各个类别的评价指标将进行累加求和，上述列子中，各指标为： $$precision &#x3D; \\frac{1}{2}\\times0.75+\\frac{1}{2}\\times0.33&#x3D;0.54$$ $$recall&#x3D; \\frac{1}{2}\\times0.43+\\frac{1}{2}\\times0.67&#x3D;0.55$$ $$F_1&#x3D; \\frac{1}{2}\\times0.55+\\frac{1}{2}\\times0.44&#x3D;0.49$$ 加权平均 所谓加权平均就是以不同的权重对各类别的评价指标累加求和，常用的一个加权方式是某个类别的样本数占总样本数的比例，上述例子中，个指标为： $$precision &#x3D; \\frac{7}{10}\\times0.75+\\frac{3}{10}\\times0.33&#x3D;0.62$$ $$recall&#x3D; \\frac{7}{10}\\times0.43+\\frac{3}{10}\\times0.67&#x3D;0.50$$ $$F_1&#x3D; \\frac{7}{10}\\times0.55+\\frac{3}{10}\\times0.44&#x3D;0.52$$ 1.2 多分类任务下面是三分类任务的真实值与预测值： 12y_true = [1, 1, 1, 0, 0, 0, 2, 2, 2, 2]y_pred = [1, 0, 0, 0, 2, 1, 0, 0, 2, 2] 1.2.1 混淆矩阵根据上面的真实值与预测值，可以得到如下混淆矩阵： 真实\\预测 0 1 2 0 1 1 1 1 2 1 0 2 2 0 2 理解上述表格，先横着看再竖着看，例如第一行第一列，表示将标签0预测成0的个数，第一行第二列，表示将标签0预测成1的个数。这样理解，只有对角线上的才是预测正确的数量。 1.2.1 指标计算首先计算样本的准确率： $$accuracy &#x3D; \\frac{1+1+2}{1+1+1+2+1+0+2+0+2} &#x3D; 0.4$$ 类别0&#x20; 精确率是指在该类别预测正确的样本数占所有预测样本的比例，类别0的预测样本有1+2+2&#x3D;5，预测对的样本为1，则类别0的精确率为： $$precision &#x3D; \\frac{1}{1+2+2}&#x3D;0.2$$ 召回率为，该类别预测正确的样本占真实样本中的比例，类别0的真实样本为1+1+1 &#x3D; 3，预测对的样本为1，则类别0的召回率为： $$recall &#x3D; \\frac{1}{1+1+1}&#x3D;0.33$$ 因此其 $$F_1$$值为： $$F_1 &#x3D; \\frac{2 \\times 0.2 \\times 0.33}{0.2 + 0.33} &#x3D; 0.25$$ 类别1 $$precision &#x3D; \\frac{1}{1+1+0}&#x3D;0.5$$ $$recall &#x3D; \\frac{1}{1+2+0}&#x3D;0.33$$ $$F_1 &#x3D; \\frac{2 \\times 0.5 \\times 0.33}{0.5 + 0.33} &#x3D; 0.40$$ 类别2 $$precision &#x3D; \\frac{2}{1+0+2}&#x3D;0.67$$ $$recall &#x3D; \\frac{2}{2+0+2}&#x3D;0.50$$ $$F_1 &#x3D; \\frac{2 \\times 0.67 \\times 0.50}{0.67 + 0.50} &#x3D; 0.57$$ 然后分别求加权后的指标： 算术评价 $$precision &#x3D; \\frac{1}{3}(0.2+0.5+0.67)&#x3D;0.46$$ $$recall &#x3D; \\frac{1}{3}(0.33+0.33+0.50)&#x3D;0.39$$ $$F_1 &#x3D; \\frac{1}{3}(0.25+0.40+0.57) &#x3D; 0.41$$ 加权平均 $$precision &#x3D; \\frac{3}{10}\\times0.2 + \\frac{3}{10}\\times0.5+ \\frac{4}{10}\\times0.67&#x3D;0.48$$ $$recall &#x3D; \\frac{3}{10}\\times0.33 + \\frac{3}{10}\\times0.33+ \\frac{4}{10}\\times0.50&#x3D;0.40$$ $$F_1 &#x3D; \\frac{3}{10}\\times0.25 + \\frac{3}{10}\\times0.40+ \\frac{4}{10}\\times0.57&#x3D;0.42$$ 1.3 实现基于sklearn很容易实现上述分类指标的统计： 1234567from sklearn import metricsy_true = [1, 1, 1, 0, 0, 0, 2, 2, 2, 2]y_pred = [1, 0, 0, 0, 2, 1, 0, 0, 2, 2]report = metrics.classification_report(y_true, y_pred))confusion = metrics.confusion_matrix(y_true, y_pred)print(report)print(confusion ) 输出为： 12345678910111213 precision recall f1-score support 0 0.20 0.33 0.25 3 1 0.50 0.33 0.40 3 2 0.67 0.50 0.57 4 accuracy 0.40 10 macro avg 0.46 0.39 0.41 10weighted avg 0.48 0.40 0.42 10[[1 1 1] [2 1 0] [2 0 2]] 2. PR，ROC曲线","tags":["ml"],"categories":["机器学习"]},{"title":"设计模式","path":"/2021/03/22/设计模式/","content":"设计模式1. 软件设计模式概述1.软件设计模式的概念软件设计模式（Software Design Pattern）,又叫设计模式，是一套被反复使用、多人知晓的、代码设计经验总结。它描述在软件设计过程中一些不断重复发生的问题，以及该问题的解决方案。也就是说它是解决经验的套路，是前辈们的代码设计经验总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性、代码的可靠性。 2.学习软件设计模式的意义设计模式的本质是面向对象程序设计的实际应用，是对类的封装、继承、多态以及对类的关联关系与组合关系的充分理解。正确使用设计模式具有以下优点： 可以提高程序员的思维能力、编程能力、设计能力。 使程序设计更加标准化、代码更加工程化、提高软件开发效率、缩短软件开发周期。 提高代码的可用性、可读性、可靠性、可维护性、灵活性。 2. GoF的23种设计模式的分类和功能设计模式有两种分类方法，即根据模式的目的来分与根据模式的作用范围来分。 1. 根据目的来分根据模式是用来完成什么工作来划分，这种模式可分为创建型模式、结构型模式、行为模式。 1 创建型模式：用于描述怎样创建对象，它的目的是将对象的创建与使用分离。GoF中提供了单例、原型、工厂方法、抽象工厂、建造者等5种创建模式。 2 结构型模式：用于描述如何将类和对象按某种布局组成更大的结构，GoF中提供了，代理、适配器、桥接、享元、装饰、外观、组合等7种结构型模式。 3 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF中提供了模版方法、策略、命令、责任链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等11种行为模式。 2. 根据作用范围来分根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。 1 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。 2 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。 3.GoF的23种设计模式的功能 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。 3.软件设计的7大原则1. 开闭原则开闭原则定义开闭原则（Open Closed Principle，OCP）由勃兰特·梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。这里的软件实体包括以下几个部分： 项目中划分出的模块 类与接口 方法 开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。 开闭原则的作用开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下：1.对软件测试的影响: 软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。2. 可以提高代码的可复用性: 粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。3. 可以提高软件的可维护性: 遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。 开闭原则的实现方法可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。 2. 里氏替换原则里氏替换原则的定义里氏替换原则（Liskov Substitution Principle，LSP）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》（Data Abstraction and Hierarchy）里提出来的，她提出：继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）。 里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。 里氏替换原则的作用里氏替换原则的主要作用如下： 里氏替换原则是实现开闭原则的重要方式之一。 它克服了继承中重写父类造成的可复用性变差的缺点。 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。 里氏替换原则的实现方法里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。 根据上述理解，对里氏替换原则的定义可以总结如下： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法 子类中可以增加自己特有的方法 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松 当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的的输出&#x2F;返回值）要比父类的方法更严格或相等 通过重写父类的方法来完成新的功能写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。 如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。 里氏替换原则在“几维鸟不是鸟”实例中的应用。 分析：鸟一般都会飞行，如燕子的飞行速度大概是每小时 120 千米。但是新西兰的几维鸟由于翅膀退化无法飞行。假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”，明显不符合预期，其类图如图 1 所示。 “几维鸟不是鸟”实例的类图 12345678910111213141516171819202122232425262728293031323334public class LSPtest &#123; public static void main(String[] args) &#123; Bird bird1 = new Swallow(); Bird bird2 = new BrownKiwi(); bird1.setSpeed(120); bird2.setSpeed(120); System.out.println(&quot;如果飞行300公里：&quot;); try &#123; System.out.println(&quot;燕子将飞行&quot; + bird1.getFlyTime(300) + &quot;小时.&quot;); System.out.println(&quot;几维鸟将飞行&quot; + bird2.getFlyTime(300) + &quot;小时。&quot;); &#125; catch (Exception err) &#123; System.out.println(&quot;发生错误了!&quot;); &#125; &#125;&#125;//鸟类class Bird &#123; double flySpeed; public void setSpeed(double speed) &#123; flySpeed = speed; &#125; public double getFlyTime(double distance) &#123; return (distance / flySpeed); &#125;&#125;//燕子类class Swallow extends Bird &#123;&#125;//几维鸟类class BrownKiwi extends Bird &#123; public void setSpeed(double speed) &#123; flySpeed = 0; &#125;&#125; 程序的运行结果如下： 如果飞行300公里： 燕子将飞行2.5小时. 几维鸟将飞行Infinity小时。 程序运行错误的原因是：几维鸟类重写了鸟类的 setSpeed(double speed) 方法，这违背了里氏替换原则。正确的做法是：取消几维鸟原来的继承关系，定义鸟和几维鸟的更一般的父类，如动物类，它们都有奔跑的能力。几维鸟的飞行速度虽然为 0，但奔跑速度不为 0，可以计算出其奔跑 300 千米所要花费的时间。其类图如图 2 所示。 “几维鸟是动物”实例的类图 3. 依赖倒置原则依赖倒置原则的定义依赖倒置原则（Dependence Inversion Principle，DIP）是 Object Mentor 公司总裁罗伯特·马丁（Robert C.Martin）于 1996 年在 C++ Report 上发表的文章。 依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：要面向接口编程，不要面向实现编程。 依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。 由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。 使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。 依赖、倒置原则的作用依赖倒置原则的主要作用如下。 依赖倒置原则可以降低类间的耦合性。 依赖倒置原则可以提高系统的稳定性。 依赖倒置原则可以减少并行开发引起的风险。 依赖倒置原则可以提高代码的可读性和可维护性。 依赖倒置原则的实现方法依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。 每个类尽量提供接口或抽象类，或者两者都具备。 变量的声明类型尽量是接口或者是抽象类。 任何类都不应该从具体类派生。 使用继承时尽量遵循里氏替换原则。 下面以“顾客购物程序”为例来说明依赖倒置原则的应用。 依赖倒置原则在“顾客购物程序”中的应用。 分析：本程序反映了 “顾客类”与“商店类”的关系。商店类中有 sell() 方法，顾客类通过该方法购物以下代码定义了顾客类通过韶关网店 ShaoguanShop 购物： 123456class Customer &#123; public void shopping(ShaoguanShop shop) &#123; //购物 System.out.println(shop.sell()); &#125;&#125; 但是，这种设计存在缺点，如果该顾客想从另外一家商店（如婺源网店 WuyuanShop）购物，就要将该顾客的代码修改如下： 123456class Customer &#123; public void shopping(WuyuanShop shop) &#123; //购物 System.out.println(shop.sell()); &#125;&#125; 顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。存在以上缺点的原因是：顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则。解决方法是：定义“婺源网店”和“韶关网店”的共同接口 Shop，顾客类面向该接口编程，其代码修改如下： 123456class Customer &#123; public void shopping(Shop shop) &#123; //购物 System.out.println(shop.sell()); &#125;&#125; 这样，不管顾客类 Customer 访问什么商店，或者增加新的商店，都不需要修改原有代码了，其类图如图所示。 顾客购物程序的类图 程序代码如下： 12345678910111213141516171819202122232425262728293031public class DIPtest &#123; public static void main(String[] args) &#123; Customer wang = new Customer(); System.out.println(&quot;顾客购买以下商品：&quot;); wang.shopping(new ShaoguanShop()); wang.shopping(new WuyuanShop()); &#125;&#125;//商店interface Shop &#123; public String sell(); //卖&#125;//韶关网店class ShaoguanShop implements Shop &#123; public String sell() &#123; return &quot;韶关土特产：香菇、木耳……&quot;; &#125;&#125;//婺源网店class WuyuanShop implements Shop &#123; public String sell() &#123; return &quot;婺源土特产：绿茶、酒糟鱼……&quot;; &#125;&#125;//顾客class Customer &#123; public void shopping(Shop shop) &#123; //购物 System.out.println(shop.sell()); &#125;&#125; 程序的运行结果如下： 顾客购买以下商品： 韶关土特产：香菇、木耳…… 婺源土特产：绿茶、酒糟鱼…… 4. 单一职责原则单一职责原则的定义单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则，由罗伯特·C.马丁（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》一书中提出的。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。 该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点： 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力； 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。 单一职责原则的优点单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。 提高类的可读性。复杂性降低，自然其可读性会提高。 提高系统的可维护性。可读性提高，那自然更容易维护了。 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。 单一职责原则的实现方法单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。下面以大学学生工作管理程序为例介绍单一职责原则的应用。 大学学生工作管理程序. 分析：大学学生工作主要包括学生生活辅导和学生学业指导两个方面的工作，其中生活辅导主要包括班委建设、出勤统计、心理辅导、费用催缴、班级管理等工作，学业指导主要包括专业引导、学习辅导、科研指导、学习总结等工作。如果将这些工作交给一位老师负责显然不合理，正确的做 法是生活辅导由辅导员负责，学业指导由学业导师负责，其类图如图所示。 大学学生工作管理程序的类图 注意：单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。 5. 接口隔离原则接口隔离原则的定义接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。 2002 年罗伯特·C.马丁给“接口隔离原则”的定义是：客户端不应该被迫依赖于它不使用的方法（Clients should not be forced to depend on methods they do not use）。该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）。 以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的： 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。 接口隔离原则的优点接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。 接口隔离原则的实现方法在具体应用接口隔离原则时，应该根据以下几个规则来衡量。 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 下面以学生成绩管理程序为例介绍接口隔离原则的应用。 学生成绩管理程序。 分析：学生成绩管理程序一般包含插入成绩、删除成绩、修改成绩、计算总分、计算均分、打印成绩信息、査询成绩信息等功能，如果将这些功能全部放到一个接口中显然不太合理，正确的做法是将它们分别放在输入模块、统计模块和打印模块等 3 个模块中，其类图如图所示。 学生成绩管理程序的类图 程序代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class ISPtest &#123; public static void main(String[] args) &#123; InputModule input = StuScoreList.getInputModule(); CountModule count = StuScoreList.getCountModule(); PrintModule print = StuScoreList.getPrintModule(); input.insert(); count.countTotalScore(); print.printStuInfo(); //print.delete(); &#125;&#125;//输入模块接口interface InputModule &#123; void insert(); void delete(); void modify();&#125;//统计模块接口interface CountModule &#123; void countTotalScore(); void countAverage();&#125;//打印模块接口interface PrintModule &#123; void printStuInfo(); void queryStuInfo();&#125;//实现类class StuScoreList implements InputModule, CountModule, PrintModule &#123; private StuScoreList() &#123; &#125; public static InputModule getInputModule() &#123; return (InputModule) new StuScoreList(); &#125; public static CountModule getCountModule() &#123; return (CountModule) new StuScoreList(); &#125; public static PrintModule getPrintModule() &#123; return (PrintModule) new StuScoreList(); &#125; public void insert() &#123; System.out.println(&quot;输入模块的insert()方法被调用！&quot;); &#125; public void delete() &#123; System.out.println(&quot;输入模块的delete()方法被调用！&quot;); &#125; public void modify() &#123; System.out.println(&quot;输入模块的modify()方法被调用！&quot;); &#125; public void countTotalScore() &#123; System.out.println(&quot;统计模块的countTotalScore()方法被调用！&quot;); &#125; public void countAverage() &#123; System.out.println(&quot;统计模块的countAverage()方法被调用！&quot;); &#125; public void printStuInfo() &#123; System.out.println(&quot;打印模块的printStuInfo()方法被调用！&quot;); &#125; public void queryStuInfo() &#123; System.out.println(&quot;打印模块的queryStuInfo()方法被调用！&quot;); &#125;&#125; 程序的运行结果如下： 输入模块的insert()方法被调用！ 统计模块的countTotalScore()方法被调用！ 打印模块的printStuInfo()方法被调用！ 6.迪米特法则迪米特法则的定义迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，产生于 1987 年美国东北大学（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩·荷兰（Ian Holland）提出，被 UML 创始者之一的布奇（Booch）普及，后来又因为在经典著作《程序员修炼之道》（The Pragmatic Programmer）提及而广为人知。 迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。 迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。 迪米特法则的优点迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。 降低了类之间的耦合度，提高了模块的相对独立性。 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。 但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。 迪米特法则的实现方法从迪米特法则的定义和特点可知，它强调以下两点： 从依赖者的角度来说，只依赖应该依赖的对象。 从被依赖者的角度说，只暴露应该暴露的方法。 所以，在运用迪米特法则时要注意以下 6 点: 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。 在类的结构设计上，尽量降低类成员的访问权限。 在类的设计上，优先考虑将一个类设置成不变类。 在对其他类的引用上，将引用其他对象的次数降到最低。 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。 谨慎使用序列化（Serializable）功能。 明星与经纪人的关系实例。 分析：明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如与粉丝的见面会，与媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则，其类图如图所示。 明星与经纪人的关系图 程序代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class LoDtest &#123; public static void main(String[] args) &#123; Agent agent = new Agent(); agent.setStar(new Star(&quot;林心如&quot;)); agent.setFans(new Fans(&quot;粉丝韩丞&quot;)); agent.setCompany(new Company(&quot;中国传媒有限公司&quot;)); agent.meeting(); agent.business(); &#125;&#125;//经纪人class Agent &#123; private Star myStar; private Fans myFans; private Company myCompany; public void setStar(Star myStar) &#123; this.myStar = myStar; &#125; public void setFans(Fans myFans) &#123; this.myFans = myFans; &#125; public void setCompany(Company myCompany) &#123; this.myCompany = myCompany; &#125; public void meeting() &#123; System.out.println(myFans.getName() + &quot;与明星&quot; + myStar.getName() + &quot;见面了。&quot;); &#125; public void business() &#123; System.out.println(myCompany.getName() + &quot;与明星&quot; + myStar.getName() + &quot;洽淡业务。&quot;); &#125;&#125;//明星class Star &#123; private String name; Star(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125;//粉丝class Fans &#123; private String name; Fans(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125;//媒体公司class Company &#123; private String name; Company(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; 程序的运行结果如下： 粉丝韩丞与明星林心如见面了。 中国传媒有限公司与明星林心如洽淡业务。 7. 合成复用原则合成复用原则的定义合成复用原则（Composite Reuse Principle，CRP）又叫组合&#x2F;聚合复用原则（Composition&#x2F;Aggregate Reuse Principle，CARP）。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。 合成复用原则的重要性通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 合成复用原则的实现方法合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。 下面以汽车分类管理程序为例来介绍合成复用原则的应用。 汽车分类管理程序。 分析：汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。图所示是用继承关系实现的汽车分类的类图。 用继承关系实现的汽车分类的类图 从图 1 可以看出用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题，其类图如图所示。 用组合关系实现的汽车分类的类图 3. 一句话总结设计模式这 7 种设计原则是软件设计模式必须尽量遵循的原则，是设计模式的基础。在实际开发过程中，并不是一定要求所有代码都遵循设计原则，而是要综合考虑人力、时间、成本、质量，不刻意追求完美，要在适当的场景遵循设计原则。这体现的是一种平衡取舍，可以帮助我们设计出更加优雅的代码结构。 一句话总结设计模式 这些原则的目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。 4. 各个设计模式详解1.单例模式在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的单例模式。 单例模式的定义与特点单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。 在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。 单例模式有 3 个特点： 单例类只有一个实例对象； 该单例对象必须由单例类自行创建； 单例类对外提供一个访问该单例的全局访问点。 单例模式的优点与缺点单例模式的优点： 单例模式可以保证内存里只有一个实例，减少了内存的开销。 可以避免对资源的多重占用。 单例模式设置全局访问点，可以优化和共享资源的访问。 单例模式的缺点： 单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。 单例模式的应用场景对于 Java 来说，单例模式可以保证在一个 JVM 中只存在单一实例。单例模式的应用场景主要有以下几个方面。 需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。 某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。 频繁访问数据库或文件的对象。 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。 单例模式的结构与实现单例模式是设计模式中最简单的模式之一。通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。 1. 单例模式的结构单例模式的主要角色如下。 单例类：包含一个实例且能自行创建这个实例的类。 访问类：使用单例的类。 单例模式结构图 2. 单例模式的实现第1种：懒汉式懒汉线程不安全实现方式： 这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 懒汉式线程安全： 这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。优点：第一次调用才初始化，避免内存浪费。缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。 12345678910public class Singleton &#123; private static volatile Singleton instance; //保证 instance 在所有线程中同步 private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 第2种：饿汉式这种方式比较常用，但容易产生垃圾对象。优点：没有加锁，执行效率会提高。缺点：类加载时就初始化，浪费内存。它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。 1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 第3种：双检锁&#x2F;双重校验锁（DCL，即 double-checked locking）这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。 DCL本质上也就是减少了锁粒度，如果第一次检查instance不为null，那么就不需要执行下面的加锁和初始化操作。因此，可以大幅降低synchronized带来的性能开销。上面代码表面上看起来，似乎两全其美。多个线程试图在同一时间创建对象时，会通过加锁来保证只有一个线程能创建对象。在对象创建好之后，执行getInstance()方法将不需要获取锁，直接返回已创建好的对象。双重检查锁定看起来似乎很完美，但这是一个错误的优化！当线程进行第一次检查的时候，代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。 1234567891011121314151617public class Singleton &#123; //必须加volatile关键字，如果不加，多线程环境下可能因为指令重排序（初始化指令与设置实例指向内存地址的指令），\t// 导致对象实例还没有完成初始化，但是已经有指向的内存地址，这个时候对象也不为null。 //\tjdk5 之后volatile 关键字在多线程环境下可禁止上述的指令重排序。 private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; // 第一次检查 synchronized (Singleton.class) &#123; // 锁 if (singleton == null) &#123; // 第二次检查 singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 第4种 静态内部类这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 2 种方式不同的是：第 2 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 2 种方式就显得很合理。 123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 第5种 枚举类枚举类实现单例比较简单： 12345678910public enum SingleInstance &#123; INSTANCE; public static SingleInstance getInstance() &#123; return INSTANCE; &#125;&#125; 只需要这样就能保证在我们代码中使用SingleInstance.getInstance()在同一进程下获取到的一定是同一个单例对象,因为INSTANCE最后会被编译器处理成static final的，并且在static模块中进行的初始化，因此它的实例化是在class被加载阶段完成，是线程安全的。这个特性也决定了枚举单例不是lazy的，如果你的单例初始化比较费时且大多数情况下只会被引用但是不会被真正调用的话，你需要使用lazy的单例模式. 在Java中，不仅通过限制enum只能声明private的构造方法来防止Enum被使用new进行实例化，而且还限制了使用反射的方法不能通过Constructor来newInstance一个枚举实例。在你尝试使用反射得到的Constructor来调用其newInstance方法来实例化enum时，回得到一个exception: 12java.lang.IllegalArgumentException: Cannot reflectively create enum objects at java.lang.reflect.Constructor.newInstance(Constructor.java:521) 这一点，使用传统的单例模式是不好来保证的。注意，虽然Enum不能被反射实例化，但是它的其他方法是可以被反射调用的，例如Enum的valueof方法实际上就是通过Class类的getEnumConstantsShared方法反射调用Enum类的values方法来实现的。 传统的单例模式要防止序列化&#x2F;反序列化的攻击必须要手动来实现readObject或者readResolve方法，这一点Enum已经我们保证了，在序列化和反序列化的时候Enum的处理是和其他类不同的，在序列化的时候实际上只写入了Enum的name成员，而没有保存ordinal成员；在反序列化的时候从ObjectInputStream中读取Enum的name成员，同时调用Enum的valueof方法传入读取的name得到对应的ordinal值。同时Enum是不支持自定义序列化和反序列化的，一些序列化和反序列化对应的函数例如readObject和writeObject及serialVersionUID等属性在Enum的序列化过程中都是被忽略的。Enum在序列化和反序列化上的特性保证了使用Enum来实现单例是经受得起序列化的攻击的。 2.原型模式首先了解下深克隆与浅克隆 浅克隆： 创建一个新对象，新对象的成员变量和原来对象的完全相同，对于非基本类型，仍指向原有对象成员变量所指向的对象的内存地址。 深克隆： 创建一个新对象，新对象的成员变量也会被克隆，不再指向原有对象成员变量的地址。 注意上述强调的是新对象的成员变量，对于浅克隆，克隆出的新对象，如果修改新对象的非基本类型成员变量，那么原有对象的相对应的成员变量也会修改。 原型模式的定义与特点原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。 原型模式的优点： Java 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。 可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。 原型模式的缺点： 需要为每一个类都配置一个 clone 方法 clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。 原型模式的实现我们将创建一个抽象类 Shape 和扩展了 Shape 类的实体类。下一步是定义类 ShapeCache，该类把 shape 对象存储在一个 Hashtable 中，并在请求的时候返回它们的克隆。 PrototypePatternDemo 类使用 ShapeCache 类来获取 Shape 对象。 原型模式UML 创建一个实现了 Cloneable 接口的抽象类。 1234567891011121314151617181920212223242526272829public abstract class Shape implements Cloneable &#123; private String id; protected String type; abstract void draw(); public String getType()&#123; return type; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public Object clone() &#123; Object clone = null; try &#123; clone = super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return clone; &#125;&#125; 创建扩展了上面抽象类的实体类。 123456789101112131415161718192021222324252627282930313233343536public class Rectangle extends Shape &#123; public Rectangle()&#123; type = &quot;Rectangle&quot;; &#125; @Override public void draw() &#123; System.out.println(&quot;Inside Rectangle::draw() method.&quot;); &#125;&#125;public class Square extends Shape &#123; public Square()&#123; type = &quot;Square&quot;; &#125; @Override public void draw() &#123; System.out.println(&quot;Inside Square::draw() method.&quot;); &#125;&#125;public class Circle extends Shape &#123; public Circle()&#123; type = &quot;Circle&quot;; &#125; @Override public void draw() &#123; System.out.println(&quot;Inside Circle::draw() method.&quot;); &#125;&#125; 创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中。 123456789101112131415161718192021222324252627public class ShapeCache &#123; private static Hashtable&lt;String, Shape&gt; shapeMap = new Hashtable&lt;String, Shape&gt;(); public static Shape getShape(String shapeId) &#123; Shape cachedShape = shapeMap.get(shapeId); return (Shape) cachedShape.clone(); &#125; // 对每种形状都运行数据库查询，并创建该形状 // shapeMap.put(shapeKey, shape); // 例如，我们要添加三种形状 public static void loadCache() &#123; Circle circle = new Circle(); circle.setId(&quot;1&quot;); shapeMap.put(circle.getId(),circle); Square square = new Square(); square.setId(&quot;2&quot;); shapeMap.put(square.getId(),square); Rectangle rectangle = new Rectangle(); rectangle.setId(&quot;3&quot;); shapeMap.put(rectangle.getId(),rectangle); &#125;&#125; PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆。 1234567891011121314public class PrototypePatternDemo &#123; public static void main(String[] args) &#123; ShapeCache.loadCache(); Shape clonedShape = (Shape) ShapeCache.getShape(&quot;1&quot;); System.out.println(&quot;Shape : &quot; + clonedShape.getType()); Shape clonedShape2 = (Shape) ShapeCache.getShape(&quot;2&quot;); System.out.println(&quot;Shape : &quot; + clonedShape2.getType()); Shape clonedShape3 = (Shape) ShapeCache.getShape(&quot;3&quot;); System.out.println(&quot;Shape : &quot; + clonedShape3.getType()); &#125;&#125; 执行程序，输出结果： 123Shape : CircleShape : SquareShape : Rectangle 3.简单工厂模式现实生活中，原始社会自给自足（没有工厂），农耕社会小作坊（简单工厂，民间酒坊），工业革命流水线（工厂方法，自产自销），现代产业链代工厂（抽象工厂，富士康）。我们的项目代码同样是由简到繁一步一步迭代而来的，但对于调用者来说，却越来越简单。 在日常开发中，凡是需要生成复杂对象的地方，都可以尝试考虑使用工厂模式来代替。 12注意：上述复杂对象指的是类的构造函数参数过多等对类的构造有影响的情况，因为类的构造过于复杂，如果直接在其他业务类内使用，则两者的耦合过重，后续业务更改，就需要在任何引用该类的源代码内进行更改，光是查找所有依赖就很消耗时间了，更别说要一个一个修改了。 工厂模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。 按实际业务场景划分，工厂模式有 3 种不同的实现方式，分别是简单工厂模式、工厂方法模式和抽象工厂模式。 我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。 在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。 简单来说，简单工厂模式有一个具体的工厂类，可以生成多个不同的产品，属于创建型设计模式。 简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，违背了“开闭原则”。 优点和缺点优点： 工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。 客户端无需知道所创建具体产品的类名，只需知道参数即可。 也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。 缺点： 简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。 使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度 系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂 简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。 对于产品种类相对较少的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。 模式的结构与实现简单工厂模式的主要角色如下： 简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。 抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。 具体产品（ConcreteProduct）：是简单工厂模式的创建目标。 我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。 FactoryPatternDemo 类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE &#x2F; RECTANGLE &#x2F; SQUARE），以便获取它所需对象的类型。 简单工厂模式 步骤 1创建一个接口: 123public interface Shape &#123; void draw();&#125; 步骤 2创建实现接口的实体类。 1234567891011121314151617181920212223public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Rectangle::draw() method.&quot;); &#125;&#125;public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Square::draw() method.&quot;); &#125;&#125;public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Circle::draw() method.&quot;); &#125;&#125; 步骤 3创建一个工厂，生成基于给定信息的实体类的对象。 123456789101112131415161718public class ShapeFactory &#123; //使用 getShape 方法获取形状类型的对象 public static Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123; return new Square(); &#125; return null; &#125;&#125; 步骤 4使用该工厂，通过传递类型信息来获取实体类的对象。 1234567891011121314151617181920212223public class FactoryPatternDemo &#123; public static void main(String[] args) &#123; //获取 Circle 的对象，并调用它的 draw 方法 Shape shape1 = ShapeFactory.getShape(&quot;CIRCLE&quot;); //调用 Circle 的 draw 方法 shape1.draw(); //获取 Rectangle 的对象，并调用它的 draw 方法 Shape shape2 = ShapeFactory.getShape(&quot;RECTANGLE&quot;); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取 Square 的对象，并调用它的 draw 方法 Shape shape3 = ShapeFactory.getShape(&quot;SQUARE&quot;); //调用 Square 的 draw 方法 shape3.draw(); &#125;&#125; 步骤 5 执行程序，输出结果： 123Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method. 4.工厂方法模式在现实生活中社会分工越来越细，越来越专业化。各种产品有专门的工厂生产，彻底告别了自给自足的小农经济时代，这大大缩短了产品的生产周期，提高了生产效率。同样，在软件开发中能否做到软件对象的生产和使用相分离呢？能否在满足“开闭原则”的前提下，客户随意增删或改变对软件相关对象的使用呢？这就是本节要讨论的问题。 简单工厂模式，提到了简单工厂模式违背了开闭原则，而“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。 优点： 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。 灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。 缺点： 类的个数容易过多，增加复杂度 增加了系统的抽象性和理解难度 抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。 应用场景: 客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。 客户不关心创建产品的细节，只关心产品的品牌 模式的结构与实现工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。本节来分析其基本结构和实现方法。 模式的结构: 工厂方法模式的主要角色如下。 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。 工厂方法模式 模式的应用实例用工厂方法模式设计畜牧场。 分析：有很多种类的畜牧场，如养马场用于养马，养牛场用于养牛，所以该实例用工厂方法模式比较适合。对养马场和养牛场等具体工厂类，只要定义一个生成动物的方法 newAnimal() 即可。 抽象产品，动物类： 123public interface Animal &#123;\tvoid show();&#125; 具体产品： 1234567891011121314public class Horse implements Animal &#123;\t@Override\tpublic void show() &#123; System.out.println(&quot;this is horse.&quot;);\t&#125;&#125;public class Cattle implements Animal &#123;\t@Override\tpublic void show() &#123; System.out.println(&quot;this is cattle.&quot;);\t&#125;&#125; 抽象工厂： 123public interface AnimalFarm &#123;\tAnimal newAnimal();&#125; 具体工厂： 12345678910111213141516public class HorseFarm implements AnimalFarm &#123;\t@Override\tpublic Animal newAnimal() &#123; System.out.println(&quot;create a horse.&quot;); return new Horse();\t&#125;&#125;public class CattleFarm implements AnimalFarm &#123;\t@Override\tpublic Animal newAnimal() &#123; System.out.println(&quot;create a cattle.&quot;); return new Cattle();\t&#125;&#125; 测试程序： 123456789public class Main &#123;\tpublic static void main(String[] args) &#123; AnimalFarm horseFarm = new HorseFarm(); AnimalFarm cattelfarm = new CattleFarm(); horseFarm.newAnimal().show(); cattelfarm.newAnimal().show();\t&#125;&#125; 程序输出： 1234create a horse.this is horse.create a cattle.this is cattle. 5.抽象工厂模式前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。 同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。 模式的定义与特点抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。 抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。 使用抽象工厂模式一般要满足以下条件。 系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。 系统一次只可能消费其中某一族产品，即同族的产品一起使用。 抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。 其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。 模式的结构与实现模式的结构抽象工厂模式的主要角色如下。 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。 实现我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器&#x2F;生成器类 FactoryProducer。 AbstractFactoryPatternDemo 类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE &#x2F; RECTANGLE &#x2F; SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color（RED &#x2F; GREEN &#x2F; BLUE），以便获取它所需对象的类型。 抽象工厂模式 步骤 1 为形状创建一个接口。 123public interface Shape &#123; void draw();&#125; 步骤 2 创建实现接口的实体类。 123456789101112131415161718192021222324public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Rectangle::draw() method.&quot;); &#125;&#125;public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Square::draw() method.&quot;); &#125;&#125;public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Circle::draw() method.&quot;); &#125;&#125; 步骤 3 为颜色创建一个接口。 123public interface Color &#123; void fill();&#125; 步骤4 创建实现接口的实体类。 1234567891011121314151617181920212223public class Red implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Red::fill() method.&quot;); &#125;&#125;public class Green implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Green::fill() method.&quot;); &#125;&#125;public class Blue implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Blue::fill() method.&quot;); &#125;&#125; 步骤 5 为 Color 和 Shape 对象创建抽象类来获取工厂。 1234public abstract class AbstractFactory &#123; public abstract Color getColor(String color); public abstract Shape getShape(String shape) ;&#125; 步骤 6 创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ShapeFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123; return new Square(); &#125; return null; &#125; @Override public Color getColor(String color) &#123; return null; &#125;&#125;public class ColorFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; return null; &#125; @Override public Color getColor(String color) &#123; if(color == null)&#123; return null; &#125; if(color.equalsIgnoreCase(&quot;RED&quot;))&#123; return new Red(); &#125; else if(color.equalsIgnoreCase(&quot;GREEN&quot;))&#123; return new Green(); &#125; else if(color.equalsIgnoreCase(&quot;BLUE&quot;))&#123; return new Blue(); &#125; return null; &#125;&#125; 步骤 7 创建一个工厂创造器&#x2F;生成器类，通过传递形状或颜色信息来获取工厂。 12345678910public class FactoryProducer &#123; public static AbstractFactory getFactory(String choice)&#123; if(choice.equalsIgnoreCase(&quot;SHAPE&quot;))&#123; return new ShapeFactory(); &#125; else if(choice.equalsIgnoreCase(&quot;COLOR&quot;))&#123; return new ColorFactory(); &#125; return null; &#125;&#125; 步骤 8 使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class AbstractFactoryPatternDemo &#123; public static void main(String[] args) &#123; //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;); //获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;); //调用 Circle 的 draw 方法 shape1.draw(); //获取形状为 Rectangle 的对象 Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取形状为 Square 的对象 Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;); //调用 Square 的 draw 方法 shape3.draw(); //获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;); //获取颜色为 Red 的对象 Color color1 = colorFactory.getColor(&quot;RED&quot;); //调用 Red 的 fill 方法 color1.fill(); //获取颜色为 Green 的对象 Color color2 = colorFactory.getColor(&quot;Green&quot;); //调用 Green 的 fill 方法 color2.fill(); //获取颜色为 Blue 的对象 Color color3 = colorFactory.getColor(&quot;BLUE&quot;); //调用 Blue 的 fill 方法 color3.fill(); &#125;&#125; 程序输出 123456Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method.Inside Red::fill() method.Inside Green::fill() method.Inside Blue::fill() method. 6. 建造者模式（Bulider模式）在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。例如，计算机是由 CPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。 生活中这样的例子很多，如游戏中的不同角色，其性别、个性、能力、脸型、体型、服装、发型等特性都有所差异；还有汽车中的方向盘、发动机、车架、轮胎等部件也多种多样；每封电子邮件的发件人、收件人、主题、内容、附件等内容也各不相同。 以上所有这些产品都是由多个部件构成的，各个部件可以灵活选择，但其创建步骤都大同小异。这类产品的创建无法用前面介绍的工厂模式描述，只有建造者模式可以很好地描述该类产品的创建。 模式的定义与特点建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 该模式的主要优点如下： 封装性好，构建和表示分离。 扩展性好，各个具体的建造者相互独立，有利于系统的解耦。 客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。 其缺点如下： 产品的组成部分必须相同，这限制了其使用范围。 如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。 建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。 实现我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。 我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。 然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo 类使用 MealBuilder 来创建一个 Meal。 创建者模式UML 步骤 1 创建一个表示食物条目和食物包装的接口。 123456789public interface Item &#123; public String name(); public Packing packing(); public float price(); &#125;public interface Packing &#123; public String pack();&#125; 步骤 2 创建实现 Packing 接口的实体类。 123456789101112131415public class Wrapper implements Packing &#123; @Override public String pack() &#123; return &quot;Wrapper&quot;; &#125;&#125;public class Bottle implements Packing &#123; @Override public String pack() &#123; return &quot;Bottle&quot;; &#125;&#125; 步骤 3 创建实现 Item 接口的抽象类，该类提供了默认的功能。 123456789101112131415161718192021public abstract class Burger implements Item &#123; @Override public Packing packing() &#123; return new Wrapper(); &#125; @Override public abstract float price();&#125;public abstract class ColdDrink implements Item &#123; @Override public Packing packing() &#123; return new Bottle(); &#125; @Override public abstract float price();&#125; 步骤 4 创建扩展了 Burger 和 ColdDrink 的实体类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class VegBurger extends Burger &#123; @Override public float price() &#123; return 25.0f; &#125; @Override public String name() &#123; return &quot;Veg Burger&quot;; &#125;&#125;public class ChickenBurger extends Burger &#123; @Override public float price() &#123; return 50.5f; &#125; @Override public String name() &#123; return &quot;Chicken Burger&quot;; &#125;&#125;public class Coke extends ColdDrink &#123; @Override public float price() &#123; return 30.0f; &#125; @Override public String name() &#123; return &quot;Coke&quot;; &#125;&#125;public class Pepsi extends ColdDrink &#123; @Override public float price() &#123; return 35.0f; &#125; @Override public String name() &#123; return &quot;Pepsi&quot;; &#125;&#125; 步骤 5 创建一个 Meal 类，带有上面定义的 Item 对象。 123456789101112131415161718192021222324public class Meal &#123; private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;(); public void addItem(Item item)&#123; items.add(item); &#125; public float getCost()&#123; float cost = 0.0f; for (Item item : items) &#123; cost += item.price(); &#125; return cost; &#125; public void showItems()&#123; for (Item item : items) &#123; System.out.print(&quot;Item : &quot;+item.name()); System.out.print(&quot;, Packing : &quot;+item.packing().pack()); System.out.println(&quot;, Price : &quot;+item.price()); &#125; &#125; &#125; 步骤 6 创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。 12345678910111213141516public class MealBuilder &#123; public Meal prepareVegMeal ()&#123; Meal meal = new Meal(); meal.addItem(new VegBurger()); meal.addItem(new Coke()); return meal; &#125; public Meal prepareNonVegMeal ()&#123; Meal meal = new Meal(); meal.addItem(new ChickenBurger()); meal.addItem(new Pepsi()); return meal; &#125;&#125; 步骤 7 BuiderPatternDemo 使用 MealBuilder 来演示建造者模式（Builder Pattern）。 123456789101112131415public class BuilderPatternDemo &#123; public static void main(String[] args) &#123; MealBuilder mealBuilder = new MealBuilder(); Meal vegMeal = mealBuilder.prepareVegMeal(); System.out.println(&quot;Veg Meal&quot;); vegMeal.showItems(); System.out.println(&quot;Total Cost: &quot; +vegMeal.getCost()); Meal nonVegMeal = mealBuilder.prepareNonVegMeal(); System.out.println(&quot; Non-Veg Meal&quot;); nonVegMeal.showItems(); System.out.println(&quot;Total Cost: &quot; +nonVegMeal.getCost()); &#125;&#125; 步骤 8 执行程序，输出结果： 12345678910Veg MealItem : Veg Burger, Packing : Wrapper, Price : 25.0Item : Coke, Packing : Bottle, Price : 30.0Total Cost: 55.0Non-Veg MealItem : Chicken Burger, Packing : Wrapper, Price : 50.5Item : Pepsi, Packing : Bottle, Price : 35.0Total Cost: 85.5 7.代理模式详见 JAVA代理实现方案与原理 8. 适配器模式（Adapter模式）","tags":["java","设计模式"],"categories":["设计模式"]},{"title":"JAVA基础","path":"/2021/03/18/JAVA基础/","content":"1. 数据类型基本数据类型 byte 8字节 char 16字节 short 16字节 int 32字节 float 32字节 double 64字节 long 32字节 boolean ～ boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。 包装类型基本类型都有对应的包装类型，通过自动拆箱与自动装箱来完成 缓存池new Integer(123) 与 Integer.valueOf(123) 的区别在于： new Integer(123)每次都会创建一个对象。 Integer.valueOf(123)会使用缓存池中的对象，多次调用会使用同一个对象的引用。 123456Integer x = new Integer(123);Integer y = new Integer(123);System.out.println(x == y); // falseInteger z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // true valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 在 Java 8 中，Integer 缓存池的大小默认为 -128~127。 1234567891011121314151617181920212223242526272829static final int low = -128;static final int high;static final Integer cache[];static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127;&#125; 编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。 基本类型对应的缓冲池如下： boolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax&#x3D; 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。 2. StringString 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）在 Java 8 中，String 内部使用 char 数组存储数据。 12345public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[];&#125; 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。 12345678public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final byte[] value; /** The identifier of the encoding used to encode the bytes in &#123;@code value&#125;. */ private final byte coder;&#125; value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 String 不可变的好处： 1 缓存hash值，因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。 2 String Pool 的需要，如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。String对象 3 安全性， String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。 4 线程安全， String 不可变性天生具备线程安全，可以在多个线程中安全地使用。 String, StringBuffer and StringBuilder1.可变形 String不可变。 StringBuffer 与 StringBuilder可变。 2.线程安全 String 不可变，线程安全。 StringBuild 不是线程安全的。 StringBuffer 是线程安全的，内部使用来synchronized进行同步。 StringPool字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 和 s2.intern() 方法取得同一个字符串引用。intern() 首先把 “aaa” 放到 String Pool 中，然后返回这个字符串引用，因此 s3 和 s4 引用的是同一个字符串。 123456String s1 = new String(&quot;aaa&quot;);String s2 = new String(&quot;aaa&quot;);System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s2.intern();System.out.println(s3 == s4); // true 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。 123String s5 = &quot;bbb&quot;;String s6 = &quot;bbb&quot;;System.out.println(s5 == s6); // true 在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。 new String(“abc”)使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。 “abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量； 而使用 new 的方式会在堆中创建一个字符串对象。 3.运算参数传递Java 的参数是以值传递的形式传入方法中，而不是引用传递。以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。 1234567891011121314151617181920public class Dog &#123; String name; Dog(String name) &#123; this.name = name; &#125; String getName() &#123; return this.name; &#125; void setName(String name) &#123; this.name = name; &#125; String getObjectAddress() &#123; return super.toString(); &#125;&#125; 在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。 1234567891011class PassByValueExample &#123; public static void main(String[] args) &#123; Dog dog = new Dog(&quot;A&quot;); func(dog); System.out.println(dog.getName()); // B &#125; private static void func(Dog dog) &#123; dog.setName(&quot;B&quot;); &#125;&#125; 但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。 12345678910111213141516public class PassByValueExample &#123; public static void main(String[] args) &#123; Dog dog = new Dog(&quot;A&quot;); System.out.println(dog.getObjectAddress()); // Dog@4554617c func(dog); System.out.println(dog.getObjectAddress()); // Dog@4554617c System.out.println(dog.getName()); // A &#125; private static void func(Dog dog) &#123; System.out.println(dog.getObjectAddress()); // Dog@4554617c dog = new Dog(&quot;B&quot;); System.out.println(dog.getObjectAddress()); // Dog@74a14482 System.out.println(dog.getName()); // B &#125;&#125; 4.关键字final,static,this,super 关键字总结final关键字final关键字意思是不可修改的，不可变的，用来修饰类、方法与变量，有以下特点： 1 final修饰的类不能被继承，final修饰的类的所有的成员方法隐式被指定为final方法。 2 final修饰的方法不能被重写。 3 final修饰的变量是常量，如果是基本数据类型，其数值一旦被初始化后便不可修改；如果是引用类型的变量，则在其初始化之后便不能指向另一个对象。使用final方法的原因有两个，一个是将方法锁定，防止任何继承类修改它的定义；第二个原因是效率，早起Java版本会讲fianl方法转化为内嵌调用，但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。 static关键字static关键字主要有以下几种使用场景： 1 修饰成员变量和成员方法：被static修饰的成员属于类，不属于这个类的某个对象，被类中所有对象共享，可通过类名直接调用。被static修饰的成员变量属于静态成员变量，静态变量存在于java内存区域的方法区。 2 静态代码块： 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次. 3 静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。 4 静态导包(用来导入类中的静态资源，1.5之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。 this关键字this关键字用于引用类的当前实例。 例如： 1234567891011class Manager &#123; Employees[] employees; void manageEmployees() &#123; int totalEmp = this.employees.length; System.out.println(&quot;Total employees: &quot; + totalEmp); this.report(); &#125; void report() &#123; &#125;&#125; 在上面的示例中，this关键字用于两个地方： this.employees.length：访问类Manager的当前实例的变量。 this.report（）：调用类Manager的当前实例的方法。此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。 super关键字super关键字用于从子类访问父类的变量和方法。 例如： 1234567891011121314public class Super &#123; protected int number; protected showNumber() &#123; System.out.println(&quot;number = &quot; + number); &#125;&#125; public class Sub extends Super &#123; void bar() &#123; super.number = 10; super.showNumber(); &#125;&#125; 在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 showNumber（） 方法。使用 this 和 super 要注意的问题： 在构造器中使用 super() 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。 this、super不能用在static方法中。 静态代码块静态代码块定义在类中方法外，在非静态代码块之前执行（静态代码块-&gt;非静态代码块-&gt;构造方法），该类不管创建多少实例，静态代码块只执行一次。一个类中的静态代码块可以有多个，位置可以随便放，不在任何方法体内，JVM加载这些类时会执行静态代码块，如果有多个静态代码块，JVM会按它们在类中出现的次序执行，每个代码块只执行一次。静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问。 静态内部类静态内部类与非静态内部类有一个非常重要的区别，非静态内部类在编译完成后会隐含的保存一个引用，该引用指向创建它的外围类，但是静态内部类没有，这就意味这： 静态内部类的创建不依赖外围类。 静态内部类不能使用任何外围类的非静态成员变量与方法。静态内部类实现单例模式：123456789101112131415public class Singleton &#123; //声明为 private 避免调用默认构造方法创建对象 private Singleton() &#123; &#125; // 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问 private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getUniqueInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance() 方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。 这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。","tags":["java"],"categories":["java"]},{"title":"JAVA代理实现方案与原理","path":"/2021/03/18/JAVA代理实现方案与原理/","content":"代理模式代理模式是较常见的模式之一，在许多框架中经常见到，比如Spring的面向切面的编程，MyBatis中缓存机制对PooledConnection的管理等。 1. 静态代理程序运行前已经存在的编译好的代理类为静态代理，静态代理的实现主要有以下步骤： 1 定义业务接口; 2 被代理类实现业务接口; 3 定义代理类并实现业务接口; 4 客户端调用; 按照这个步骤去实现静态代理。需求：在向数据库添加一个用户时前后打印日志。 业务接口 IUserService.java123public interface IUserService &#123; void add(String name); &#125; 被代理类实现业务接口 IUserServiceImpl.java12345678public class UserServiceImpl implements IUserService&#123; @Override public void add(String name) &#123; System.out.println(&quot;向数据库中插入名为： &quot;+name+&quot; 的用户&quot;); &#125;&#125; 定义代理类并实现业务接口1234567891011121314151617public class UserServiceProxy implements IUserService &#123; // 被代理对象 private IUserService target; // 通过构造方法传入被代理对象 public UserServiceProxy(IUserService target) &#123; this.target = target; &#125; @Override public void add(String name) &#123; System.out.println(&quot;准备向数据库中插入数据&quot;); target.add(name); System.out.println(&quot;插入数据库成功&quot;); &#125;&#125; 由于代理类(UserServiceProxy )和被代理类(UserServiceImpl )都实现了IUserService接口，所以都有add方法，在代理类的add方法中调用了被代理类的add方法，并在其前后各打印一条日志。 客户端调用12345678public class StaticProxyTest &#123; public static void main(String[] args) &#123; IUserService target = new UserServiceImpl(); UserServiceProxy proxy = new UserServiceProxy(target); proxy.add(&quot;测试&quot;); &#125;&#125; 2. 动态代理静态代理的缺点： 1 代理类和被代理类实现了相同的接口，导致代码的重复，如果接口增加一个方法，那么除了被代理类需要实现这个方法外，代理类也要实现这个方法，增加了代码维护的难度。 2 代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。比如上面的例子，只是对用户的业务功能（IUserService）进行代理，如果是商品（IItemService）的业务功能那就无法代理，需要去编写商品服务的代理类。 动态代理能够解决上述的缺点，所谓动态代理是指：在程序运行期间根据需要动态创建代理类及其实例来完成具体的功能。动态代理主要分为JDK动态代理和cglib动态代理两大类。 2.1 JDK动态代理JDK动态代理的使用步骤： 1 创建被代理的接口和类; 2 创建InvocationHandler接口的实现类，在invoke方法中实现代理逻辑; 3 通过Proxy的静态方法newProxyInstance( ClassLoaderloader, Class[] interfaces, InvocationHandler h)创建一个代理对象; 4 使用代理; InvocationHandler的作用在动态代理中InvocationHandler是核心，每个代理实例都具有一个关联的调用处理程序InvocationHandler。对代理实例调用方法时，将对方法调用进行编码并将其指派到它的调用处理程序InvocationHandler的 invoke 方法。所以对代理方法的调用都是通InvocationHadler的invoke来实现中，而invoke方法根据传入的代理对象，方法和参数来决定调用代理的哪个方法。invoke方法签名：invoke（Object Proxy，Method method，Object[] args） 12345678910111213141516171819public class MyInvocationHandler implements InvocationHandler &#123; //被代理对象，Object类型 private Object target; public MyInvocationHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;准备向数据库中插入数据&quot;); Object returnvalue = method.invoke(target, args); System.out.println(&quot;插入数据库成功&quot;); return returnvalue; &#125;&#125; 使用动态代理 12345678910111213public class Main &#123; public static void main(String[] args) &#123; IUserService target = new UserServiceImpl(); MyInvocationHandler handler = new MyInvocationHandler(target); //第一个参数是指定代理类的类加载器（我们传入当前测试类的类加载器） //第二个参数是代理类需要实现的接口（我们传入被代理类实现的接口，这样生成的代理类和被代理类就实现了相同的接口） //第三个参数是invocation handler，用来处理方法的调用。这里传入我们自己实现的handler IUserService proxyObject = (IUserService) Proxy.newProxyInstance(DynamicProxyTest.class.getClassLoader(), target.getClass().getInterfaces(), handler); proxyObject.add(&quot;测试&quot;); &#125;&#125; 与静态代理相比，动态代理并没有主动创建一个代理类，并实例化代理对象，实际上，动态代理的代理对象是在内存中的，是JDK根据我们传入的参数生成好的。那动态代理的代理类和代理对象是怎么产生的呢？通过JDK的源码来分析。 JDK动态代理源码分析Proxy.newProxyInstance( ClassLoaderloader, Class[] interfaces, InvocationHandler h)产生了代理对象，所以我们进到newProxyInstance: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Proxy implements java.io.Serializable &#123; public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; Objects.requireNonNull(h); // copy接口的类对象 final Class&lt;?&gt;[] intfs = interfaces.clone(); // 安全检查 final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * Look up or generate the designated proxy class. * 查询缓存，或者生成指定的代理类 */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; // 获取代理类的构造函数，Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler.class &#125;; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; // 生成代理类对象 return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125;&#125; 这段代码核心就是通过getProxyClass0(loader, intfs)得到代理类的Class对象，然后通过Class对象得到构造方法，进而创建代理对象。下一步看getProxyClass0这个方法。 123456789101112131415public class Proxy implements java.io.Serializable &#123;\tprivate static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException(&quot;interface limit exceeded&quot;); &#125; // If the proxy class defined by the given loader implementing // the given interfaces exists, this will simply return the cached copy; // otherwise, it will create the proxy class via the ProxyClassFactory //意思是：如果代理类被指定的类加载器loader定义了，并实现了给定的接口interfaces， //那么就返回缓存的代理类对象，否则使用ProxyClassFactory创建代理类。 return proxyClassCache.get(loader, interfaces); &#125;&#125; 这里看到proxyClassCache，有Cache便知道是缓存的意思，正好呼应了前面Look up or generate the designated proxy class。查询（在缓存中已经有）或生成指定的代理类的class对象这段注释。在进入get方法之前，我们看下 proxyClassCache是什么: 1234public class Proxy implements java.io.Serializable &#123;\tprivate static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());&#125; proxyClassCache是个WeakCache类的对象，调用proxyClassCache.get(loader, interfaces); 可以得到缓存的代理类或创建代理类（没有缓存的情况）。说明WeakCache中有get这个方法。先看下WeakCache类的定义（这里先只给出变量的定义和构造函数） 123456789101112131415161718192021//K代表key的类型，P代表参数的类型，V代表value的类型。// WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache 说明proxyClassCache存的值是Class&lt;?&gt;对象，正是我们需要的代理类对象。final class WeakCache&lt;K, P, V&gt; &#123; private final ReferenceQueue&lt;K&gt; refQueue = new ReferenceQueue&lt;&gt;(); // the key type is Object for supporting null key private final ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map = new ConcurrentHashMap&lt;&gt;(); private final ConcurrentMap&lt;Supplier&lt;V&gt;, Boolean&gt; reverseMap = new ConcurrentHashMap&lt;&gt;(); private final BiFunction&lt;K, P, ?&gt; subKeyFactory; private final BiFunction&lt;K, P, V&gt; valueFactory; public WeakCache(BiFunction&lt;K, P, ?&gt; subKeyFactory, BiFunction&lt;K, P, V&gt; valueFactory) &#123; this.subKeyFactory = Objects.requireNonNull(subKeyFactory); this.valueFactory = Objects.requireNonNull(valueFactory); &#125;&#125; 其中map变量是实现缓存的核心变量，他是一个双重的Map结构: (key, sub-key) -&gt; value。其中key是传进来的Classloader进行包装后的对象，sub-key是由WeakCache构造函数传人的KeyFactory()生成的。value就是产生代理类的对象，是由WeakCache构造函数传人的ProxyClassFactory()生成的。如下，回顾一下: 1234public class Proxy implements java.io.Serializable &#123;\tprivate static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());&#125; 产生sub-key的KeyFactory代码如下，这个我们不去深究，只要知道他是根据传入的ClassLoader和接口类生成sub-key即可。 12345678910111213private static final class KeyFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Object&gt; &#123; @Override public Object apply(ClassLoader classLoader, Class&lt;?&gt;[] interfaces) &#123; switch (interfaces.length) &#123; case 1: return new Key1(interfaces[0]); // the most frequent case 2: return new Key2(interfaces[0], interfaces[1]); case 0: return key0; default: return new KeyX(interfaces); &#125; &#125; &#125; 通过sub-key拿到一个Supplier&lt;Class&lt;?&gt;&gt;对象，然后调用这个对象的get方法，最终得到代理类的Class对象。好，大体上说完WeakCache这个类的作用，我们回到刚才proxyClassCache.get(loader, interfaces);这句代码。get是WeakCache里的方法。源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172final class WeakCache&lt;K, P, V&gt; &#123;\t//K和P就是WeakCache定义中的泛型，key是类加载器，parameter是接口类数组 public V get(K key, P parameter) &#123; //检查parameter不为空 Objects.requireNonNull(parameter); //清除无效的缓存 expungeStaleEntries(); // cacheKey就是(key, sub-key) -&gt; value里的一级key， Object cacheKey = CacheKey.valueOf(key, refQueue); // lazily install the 2nd level valuesMap for the particular cacheKey //根据一级key得到 ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;对象。如果之前不存在，则新建一个ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;和cacheKey（一级key）一起放到map中。 ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey); if (valuesMap == null) &#123; ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey, valuesMap = new ConcurrentHashMap&lt;&gt;()); if (oldValuesMap != null) &#123; valuesMap = oldValuesMap; &#125; &#125; // create subKey and retrieve the possible Supplier&lt;V&gt; stored by that // subKey from valuesMap //这部分就是调用生成sub-key的代码，上面我们已经看过怎么生成的了 Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter)); //通过sub-key得到supplier Supplier&lt;V&gt; supplier = valuesMap.get(subKey); //supplier实际上就是这个factory Factory factory = null; while (true) &#123; //如果缓存里有supplier ，那就直接通过get方法，得到代理类对象，返回，就结束了，一会儿分析get方法。 if (supplier != null) &#123; // supplier might be a Factory or a CacheValue&lt;V&gt; instance V value = supplier.get(); if (value != null) &#123; return value; &#125; &#125; // else no supplier in cache // or a supplier that returned null (could be a cleared CacheValue // or a Factory that wasn&#x27;t successful in installing the CacheValue) // lazily construct a Factory //下面的所有代码目的就是：如果缓存中没有supplier，则创建一个Factory对象，把factory对象在多线程的环境下安全的赋给supplier。 //因为是在while（true）中，赋值成功后又回到上面去调get方法，返回才结束。 if (factory == null) &#123; factory = new Factory(key, parameter, subKey, valuesMap); &#125; if (supplier == null) &#123; supplier = valuesMap.putIfAbsent(subKey, factory); if (supplier == null) &#123; // successfully installed Factory supplier = factory; &#125; // else retry with winning supplier &#125; else &#123; if (valuesMap.replace(subKey, supplier, factory)) &#123; // successfully replaced // cleared CacheEntry / unsuccessful Factory // with our Factory supplier = factory; &#125; else &#123; // retry with current supplier supplier = valuesMap.get(subKey); &#125; &#125; &#125; &#125;&#125; 所以接下来我们看Factory类中的get方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 private final class Factory implements Supplier&lt;V&gt; &#123;\tpublic synchronized V get() &#123; // serialize access // re-check Supplier&lt;V&gt; supplier = valuesMap.get(subKey); //重新检查得到的supplier是不是当前对象 if (supplier != this) &#123; // something changed while we were waiting: // might be that we were replaced by a CacheValue // or were removed because of failure -&gt; // return null to signal WeakCache.get() to retry // the loop return null; &#125; // else still us (supplier == this) // create new value V value = null; try &#123; //代理类就是在这个位置调用valueFactory生成的 //valueFactory就是我们传入的 new ProxyClassFactory() //一会我们分析ProxyClassFactory()的apply方法 value = Objects.requireNonNull(valueFactory.apply(key, parameter)); &#125; finally &#123; if (value == null) &#123; // remove us on failure valuesMap.remove(subKey, this); &#125; &#125; // the only path to reach here is with non-null value assert value != null; // wrap value with CacheValue (WeakReference) //把value包装成弱引用 CacheValue&lt;V&gt; cacheValue = new CacheValue&lt;&gt;(value); // put into reverseMap // reverseMap是用来实现缓存的有效性 reverseMap.put(cacheValue, Boolean.TRUE); // try replacing us with CacheValue (this should always succeed) if (!valuesMap.replace(subKey, this, cacheValue)) &#123; throw new AssertionError(&quot;Should not reach here&quot;); &#125; // successfully replaced us with new CacheValue -&gt; return the value // wrapped by it return value; &#125;&#125; 拨云见日，来到ProxyClassFactory的apply方法，代理类就是在这里生成的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123; // prefix for all proxy class names //所有代理类名字的前缀 private static final String proxyClassNamePrefix = &quot;$Proxy&quot;; // next number to use for generation of unique proxy class names //用于生成代理类名字的计数器 private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); //验证代理接口，可不看 for (Class&lt;?&gt; intf : interfaces) &#123; /* * Verify that the class loader resolves the name of this * interface to the same Class object. */ Class&lt;?&gt; interfaceClass = null; try &#123; interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + &quot; is not visible from class loader&quot;); &#125; /* * Verify that the Class object actually represents an * interface. */ if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + &quot; is not an interface&quot;); &#125; /* * Verify that this interface is not a duplicate. */ if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( &quot;repeated interface: &quot; + interfaceClass.getName()); &#125; &#125; //生成的代理类的包名 String proxyPkg = null; // package to define proxy class in //代理类访问控制符: public ,final int accessFlags = Modifier.PUBLIC | Modifier.FINAL; /* * Record the package of a non-public proxy interface so that the * proxy class will be defined in the same package. Verify that * all non-public proxy interfaces are in the same package. */ //验证所有非公共的接口在同一个包内；公共的就无需处理 //生成包名和类名的逻辑，包名默认是com.sun.proxy，类名默认是$Proxy 加上一个自增的整数值 //如果被代理类是 non-public proxy interface ，则用和被代理类接口一样的包名 for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf(&#x27;.&#x27;); String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( &quot;non-public interfaces from different packages&quot;); &#125; &#125; &#125; if (proxyPkg == null) &#123; // if no non-public proxy interfaces, use com.sun.proxy package proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;; &#125; /* * Choose a name for the proxy class to generate. */ long num = nextUniqueNumber.getAndIncrement(); //代理类的完全限定名，如com.sun.proxy.$Proxy0.calss String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * Generate the specified proxy class. */ //核心部分，生成代理类的字节码 byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; //把代理类加载到JVM中，至此动态代理过程基本结束了 return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); &#125; &#125; &#125; 到这里其实已经分析完了，但是本着深究的态度，决定看看JDK生成的动态代理字节码是什么，于是我们将字节码保存到磁盘上的class文件中。代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import com.zhb.jdk.proxy.IUserService;import java.lang.reflect.*;public final class $Proxy0 extends Proxy implements IUserService&#123; private static Method m1; private static Method m2; private static Method m3; private static Method m0; //代理类的构造函数，其参数正是是InvocationHandler实例， //Proxy.newInstance方法就是通过通过这个构造函数来创建代理实例的 public $Proxy0(InvocationHandler invocationhandler) &#123; super(invocationhandler); &#125; // Object类中的三个方法，equals，toString， hashCode public final boolean equals(Object obj) &#123; try &#123; return ((Boolean)super.h.invoke(this, m1, new Object[] &#123; obj &#125;)).booleanValue(); &#125; catch (Error ) &#123; &#125; catch (Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125; public final String toString() &#123; try &#123; return (String)super.h.invoke(this, m2, null); &#125; catch (Error ) &#123; &#125; catch (Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125; //接口代理方法 public final void add(String s) &#123; try &#123; // invocation handler的 invoke方法在这里被调用 super.h.invoke(this, m3, new Object[] &#123; s &#125;); return; &#125; catch (Error ) &#123; &#125; catch (Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125; public final int hashCode() &#123; try &#123; // 在这里调用了invoke方法。 return ((Integer)super.h.invoke(this, m0, null)).intValue(); &#125; catch (Error ) &#123; &#125; catch (Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125; // 静态代码块对变量进行一些初始化工作 static &#123; try &#123; m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]); m3 = Class.forName(&quot;com.zhb.jdk.proxy.IUserService&quot;).getMethod(&quot;add&quot;, new Class[] &#123; Class.forName(&quot;java.lang.String&quot;) &#125;); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]); &#125; catch (NoSuchMethodException nosuchmethodexception) &#123; throw new NoSuchMethodError(nosuchmethodexception.getMessage()); &#125; catch (ClassNotFoundException classnotfoundexception) &#123; throw new NoClassDefFoundError(classnotfoundexception.getMessage()); &#125; &#125;&#125; 生成了Object类的三个方法：toString，hashCode，equals。还有我们需要被代理的方法。 转自：https://www.jianshu.com/p/269afd0a52e6 2.2 CJLIB动态代理 JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。 为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。 CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。 在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。 你需要自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法。 1234567public interface MethodInterceptorextends Callback&#123; // 拦截被代理类中的方法 public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args, MethodProxy proxy) throws Throwable;&#125; 1 obj :被代理的对象（需要增强的对象） 2 method :被拦截的方法（需要增强的方法） 3 args :方法入参 4 methodProxy :用于调用原始方法 你可以通过 Enhancer类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 MethodInterceptor 中的 intercept 方法。 CGLIB 动态代理类使用步骤 1 定义一个类； 2 自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似； 3 通过 Enhancer 类的 create()创建代理类； maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 实现一个使用阿里云发送短信的类 123456public class AliSmsService &#123; public String send(String message) &#123; System.out.println(&quot;send message:&quot; + message); return message; &#125;&#125; 自定义 MethodInterceptor（方法拦截器） 1234567891011121314151617181920public class DebugMethodInterceptor implements MethodInterceptor &#123; /** * @param o 被代理的对象（需要增强的对象） * @param method 被拦截的方法（需要增强的方法） * @param args 方法入参 * @param methodProxy 用于调用原始方法 */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; //调用方法之前，我们可以添加自己的操作 System.out.println(&quot;before method &quot; + method.getName()); Object object = methodProxy.invokeSuper(o, args); //调用方法之后，我们同样可以添加自己的操作 System.out.println(&quot;after method &quot; + method.getName()); return object; &#125;&#125; 获取代理类 123456789101112131415public class CglibProxyFactory &#123; public static Object getProxy(Class&lt;?&gt; clazz) &#123; // 创建动态代理增强类 Enhancer enhancer = new Enhancer(); // 设置类加载器 enhancer.setClassLoader(clazz.getClassLoader()); // 设置被代理类 enhancer.setSuperclass(clazz); // 设置方法拦截器 enhancer.setCallback(new DebugMethodInterceptor()); // 创建代理类 return enhancer.create(); &#125;&#125; 使用 12AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);aliSmsService.send(&quot;java&quot;); JDK 动态代理和 CGLIB 动态代理对比 1 JDK 动态代理只能只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。 2 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。 静态代理和动态代理的对比 1 灵活性 ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！ 2 JVM 层面 ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。","tags":["java 代理"],"categories":["java 代理"]},{"title":"JVM运行时数据区","path":"/2020/12/18/JVM运行时数据区/","content":"运行时数据区域jvm运行时数据区","tags":["jvm"],"categories":["jvm"]},{"title":"SpringBoot中WebMvcConfigurer接口","path":"/2019/09/24/SpringBoot中WebMvcConfigurer接口/","content":"SpringBoot中WebMvcConfigurer接口java8之前，WebMvcConfigurerAdapter还是WebMvcConfigurer的实现抽象类，WebMvcConfigurerAdapter没有被标注为@Deprecated被遗弃的类。 JDK8的一些新特性——在接口中新增了default方法和static方法，这两种方法可以有方法体。 java8新特性 运用之后: 对比 在Spring Boot 1.5版本都是靠重写WebMvcConfigurerAdapter的方法来添加自定义拦截器，消息转换器等。SpringBoot 2.0 后，该类被标记为@Deprecated。因此我们只能靠实现WebMvcConfigurer接口来实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package org.springframework.web.servlet.config.annotation;import java.util.List;import org.springframework.format.FormatterRegistry;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.lang.Nullable;import org.springframework.validation.MessageCodesResolver;import org.springframework.validation.Validator;import org.springframework.web.method.support.HandlerMethodArgumentResolver;import org.springframework.web.method.support.HandlerMethodReturnValueHandler;import org.springframework.web.servlet.HandlerExceptionResolver;public interface WebMvcConfigurer &#123; default void configurePathMatch(PathMatchConfigurer configurer) &#123; &#125; default void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123; &#125; default void configureAsyncSupport(AsyncSupportConfigurer configurer) &#123; &#125; default void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; &#125; default void addFormatters(FormatterRegistry registry) &#123; &#125; default void addInterceptors(InterceptorRegistry registry) &#123; &#125; default void addResourceHandlers(ResourceHandlerRegistry registry) &#123; &#125; default void addCorsMappings(CorsRegistry registry) &#123; &#125; default void addViewControllers(ViewControllerRegistry registry) &#123; &#125; default void configureViewResolvers(ViewResolverRegistry registry) &#123; &#125; default void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123; &#125; default void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; handlers) &#123; &#125; default void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; &#125; default void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; &#125; default void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123; &#125; default void extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123; &#125; @Nullable default Validator getValidator() &#123; return null; &#125; @Nullable default MessageCodesResolver getMessageCodesResolver() &#123; return null; &#125;&#125; 只需实现相应的接口的方法，就能实现具体的功能： 123456789101112@Configurationpublic class WebConfig implements WebMvcConfigurer &#123; /** * 添加类型转换器和格式化器 * @param registry */ @Override public void addFormatters(FormatterRegistry registry) &#123; registry.addFormatterForFieldType(LocalDate.class, new USLocalDateFormatter()); &#125;&#125; 配置拦截器拦截器配置如下所示，InterceptorRegistry 内的addInterceptor需要一个实现HandlerInterceptor接口的拦截器实例，addPathPatterns方法用于设置拦截器的过滤路径规则。 1234567public class WebConfig implements WebMvcConfigurer &#123;\t@Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new ReqInterceptor()).addPathPatterns(&quot;/**&quot;); &#125; &#125; 实现拦截器： 12345678910111213141516171819202122232425262728293031323334import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * l拦截器实现 */public class ReqInterceptor extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;Interceptor preHandler method is running !&quot;); return super.preHandle(request, response, handler); &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;Interceptor postHandler method is running !&quot;); super.postHandle(request, response, handler, modelAndView); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;Interceptor afterCompletion method is running !&quot;); super.afterCompletion(request, response, handler, ex); &#125; @Override public void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;Interceptor afterConcurrentHandlingStarted method is running !&quot;); super.afterConcurrentHandlingStarted(request, response, handler); &#125;&#125; 配置CORS实现跨域1234567891011121314151617181920public class WebConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new ReqInterceptor()).addPathPatterns(&quot;/**&quot;); &#125; /** * 跨域支持 */ @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedOrigins(&quot;*&quot;) .allowCredentials(true) .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;) .maxAge(3600); &#125; &#125; 配置ViewController这一个配置在之前是经常被使用到的，最经常用到的就是”&#x2F;“、”&#x2F;index”路径请求时不通过@RequestMapping配置，而是直接通过配置文件映射指定请求路径到指定View页面，当然也是在请求目标页面时不需要做什么数据处理才可以这样使用，配置内容如下所示： 12345678910111213141516171819202122232425262728public class WebConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new ReqInterceptor()).addPathPatterns(&quot;/**&quot;); &#125; /** * 跨域支持 */ @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedOrigins(&quot;*&quot;) .allowCredentials(true) .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;) .maxAge(3600); &#125; /** * 视图控制器配置 */ @Override public void addViewControllers(ViewControllerRegistry registry) &#123; super.addViewControllers(registry); registry.addViewController(&quot;/&quot;).setViewName(&quot;/index&quot;); &#125; &#125; 配置ViewResolver123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class WebConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new ReqInterceptor()).addPathPatterns(&quot;/**&quot;); &#125; /** * 跨域支持 */ @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedOrigins(&quot;*&quot;) .allowCredentials(true) .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;) .maxAge(3600); &#125; /** * 视图控制器配置 */ @Override public void addViewControllers(ViewControllerRegistry registry) &#123; super.addViewControllers(registry); registry.addViewController(&quot;/&quot;).setViewName(&quot;/index&quot;); &#125; /** * 配置请求视图映射 */ @Bean public InternalResourceViewResolver resourceViewResolver() &#123; InternalResourceViewResolver internalResourceViewResolver = new InternalResourceViewResolver(); //请求视图文件的前缀地址 internalResourceViewResolver.setPrefix(&quot;/WEB-INF/jsp/&quot;); //请求视图文件的后缀 internalResourceViewResolver.setSuffix(&quot;.jsp&quot;); return internalResourceViewResolver; &#125; /** * 视图配置 */ @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; super.configureViewResolvers(registry); registry.viewResolver(resourceViewResolver()); /*registry.jsp(&quot;/WEB-INF/jsp/&quot;,&quot;.jsp&quot;);*/ &#125; &#125; 配置MessageConverter这个配置一般针对于Api接口服务程序，配置在请求返回时内容采用什么转换器进行转换，我们最常用到的就是fastJson的转换，配置如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class WebConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new ReqInterceptor()).addPathPatterns(&quot;/**&quot;); &#125; /** * 跨域支持 */ @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedOrigins(&quot;*&quot;) .allowCredentials(true) .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;) .maxAge(3600); &#125; /** * 视图控制器配置 */ @Override public void addViewControllers(ViewControllerRegistry registry) &#123; super.addViewControllers(registry); registry.addViewController(&quot;/&quot;).setViewName(&quot;/index&quot;); &#125; /** * 配置请求视图映射 */ @Bean public InternalResourceViewResolver resourceViewResolver() &#123; InternalResourceViewResolver internalResourceViewResolver = new InternalResourceViewResolver(); //请求视图文件的前缀地址 internalResourceViewResolver.setPrefix(&quot;/WEB-INF/jsp/&quot;); //请求视图文件的后缀 internalResourceViewResolver.setSuffix(&quot;.jsp&quot;); return internalResourceViewResolver; &#125; /** * 视图配置 */ @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; super.configureViewResolvers(registry); registry.viewResolver(resourceViewResolver()); /*registry.jsp(&quot;/WEB-INF/jsp/&quot;,&quot;.jsp&quot;);*/ &#125; /** * 消息内容转换配置 * 配置fastJson返回json转换 * @param converters */ @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; //调用父类的配置 super.configureMessageConverters(converters); //创建fastJson消息转换器 FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter(); //创建配置类 FastJsonConfig fastJsonConfig = new FastJsonConfig(); //修改配置返回内容的过滤 fastJsonConfig.setSerializerFeatures( SerializerFeature.DisableCircularReferenceDetect, SerializerFeature.WriteMapNullValue, SerializerFeature.WriteNullStringAsEmpty ); fastConverter.setFastJsonConfig(fastJsonConfig); //将fastjson添加到视图消息转换器列表内 converters.add(fastConverter); &#125; &#125; 内容转换都是针对面向接口进行编写的实现类，都必须implements HttpMessageConverter接口完成方法的实现。","tags":["spring","spring boot"],"categories":["spring boot"]},{"title":"过滤器（Filter）与拦截器（Interceptor )区别","path":"/2019/09/23/过滤器（Filter）与拦截器（Interceptor-区别/","content":"过滤器（Filter）Servlet中的过滤器Filter是实现了javax.servlet.Filter接口的服务器端程序，主要的用途是设置字符集、控制权限、控制转向、做一些业务逻辑判断等。其工作原理是，只要你在web.xml文件配置好要拦截的客户端请求，它都会帮你拦截到请求，此时你就可以对请求或响应(Request、Response)统一设置编码，简化操作；同时还可进行逻辑判断，如用户是否已经登陆、有没有权限访问该页面等等工作。它是随你的web应用启动而启动的，只初始化一次，以后就可以拦截相关请求，只有当你的web应用停止或重新部署的时候才销毁。 Filter可以认为是Servlet的一种“加强版”，它主要用于对用户请求进行预处理，也可以对HttpServletResponse进行后处理，是个典型的处理链。Filter也可以对用户请求生成响应，这一点与Servlet相同，但实际上很少会使用Filter向用户请求生成响应。使用Filter完整的流程是：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。 Filter有如下几个用处 在HttpServletRequest到达Servlet之前，拦截客户的HttpServletRequest。 根据需要检查HttpServletRequest，也可以修改HttpServletRequest头和数据。 在HttpServletResponse到达客户端之前，拦截HttpServletResponse。 根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。 Filter有如下几个种类。 用户授权的Filter：Filter负责检查用户请求，根据请求过滤用户非法请求。 日志Filter：详细记录某些特殊的用户请求。 负责解码的Filter:包括对非标准编码的请求解码。 能改变XML内容的XSLT Filter等。 Filter可以负责拦截多个请求或响应；一个请求或响应也可以被多个Filter拦截。 创建一个Filter只需两个步骤 创建Filter处理类。 配置Filter。 创建Filter必须实现javax.servlet.Filter接口，在该接口中定义了如下三个方法。 void init(FilterConfig config):用于完成Filter的初始化。 void destory():用于Filter销毁前，完成某些资源的回收。 void doFilter(ServletRequest request,ServletResponse response,FilterChain chain):实现过滤功能，该方法就是对每个请求及响应增加的额外处理。该方法可以实现对用户请求进行预处理(ServletRequest request)，也可实现对服务器响应进行后处理(ServletResponse response)—它们的分界线为是否调用了chain.doFilter(),执行该方法之前，即对用户请求进行预处理；执行该方法之后，即对服务器响应进行后处理。 拦截器（Interceptor）拦截器是在面向切面编程中应用的，就是在你的service或者一个方法前调用一个方法，或者在方法后调用一个方法。是基于JAVA的反射机制。 拦截器，在AOP(Aspect-Oriented Programming)中用于在某个方法或字段被访问之前，进行拦截，然后在之前或之后加入某些操作。拦截是AOP的一种实现策略。在WebWork的中文文档的解释为—拦截器是动态拦截Action调用的对象。它提供了一种机制使开发者可以定义在一个Action执行的前后执行的代码，也可以在一个Action执行前阻止其执行。同时也提供了一种可以提取Action中可重用的部分的方式。 拦截器将Action共用的行为独立出来，在Action执行前后执行。这也就是我们所说的AOP，它是分散关注的编程方法，它将通用需求功能从不相关类之中分离出来；同时，能够共享一个行为，一旦行为发生变化，不必修改很多类，只要修改这个行为就可以。拦截器将很多功能从我们的Action中独立出来，大量减少了我们Action的代码，独立出来的行为就有很好的重用性。 当你提交对Action(默认是.action结尾的url)的请求时，ServletDispatcher会根据你的请求，去调度并执行相应的Action。在Action执行之前，调用被Interceptor截取，Interceptor在Action执行前后执行。 SpringMVC 中的Interceptor 拦截请求是通过HandlerInterceptor 来实现的。在SpringMVC 中定义一个Interceptor 非常简单，主要有两种方式，第一种方式是要定义的Interceptor类要实现了Spring 的HandlerInterceptor 接口，或者是这个类继承实现了HandlerInterceptor 接口的类，比如Spring 已经提供的实现了HandlerInterceptor 接口的抽象类HandlerInterceptorAdapter ；第二种方式是实现Spring的WebRequestInterceptor接口，或者是继承实现了WebRequestInterceptor的类。 preHandle (HttpServletRequest request, HttpServletResponse response, Object handle) 方法，顾名思义，该方法将在请求处理之前进行调用。SpringMVC 中的Interceptor 是链式的调用的，在一个应用中或者说是在一个请求中可以同时存在多个Interceptor 。每个Interceptor 的调用会依据它的声明顺序依次执行，而且最先执行的都是Interceptor 中的preHandle 方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求的一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值Boolean类型的，当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会再执行；当返回值为true 时就会继续调用下一个Interceptor 的preHandle 方法，如果已经是最后一个Interceptor 的时候就会是调用当前请求的Controller 方法。 postHandle (HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView) 方法，由preHandle 方法的解释我们知道这个方法包括后面要说到的afterCompletion 方法都只能是在当前所属的Interceptor 的preHandle 方法的返回值为true时才能被调用。postHandle 方法，顾名思义就是在当前请求进行处理之后，也就是Controller 方法调用之后执行，但是它会在DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller 处理之后的ModelAndView 对象进行操作。postHandle 方法被调用的方向跟preHandle是相反的，也就是说先声明的Interceptor 的postHandle 方法反而会后执行。 afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex) 方法，该方法也是需要当前对应的Interceptor 的preHandle 方法的返回值为true 时才会执行。顾名思义，该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行。这个方法的主要作用是用于进行资源清理工作的。 拦截器（Interceptor）和过滤器（Filter）的区别Spring的Interceptor(拦截器)与Servlet的Filter有相似之处，比如二者都是AOP编程思想的体现，都能实现权限检查、日志记录等。不同的是： Filter Interceptor Summary Filter 接口定义在 javax.servlet 包中 接口 HandlerInterceptor 定义在org.springframework.web.servlet 包中 Filter 定义在 web.xml 中 Filter在只在 Servlet 前后起作用。Filters 通常将 请求和响应（request&#x2F;response） 当做黑盒子，Filter 通常不考虑servlet 的实现。 拦截器能够深入到方法前后、异常抛出前后等，因此拦截器的使用具有更大的弹性。允许用户介入（hook into）请求的生命周期，在请求过程中获取信息，Interceptor 通常和请求更加耦合。 优先使用拦截器 Filter 是 Servlet 规范规定的。 而拦截器既可以用于Web程序，也可以用于Application、Swing程序中。 使用范围不同 Filter 是在 Servlet 规范中定义的，是 Servlet 容器支持的 而拦截器是在 Spring容器内的，是Spring框架支持的。 规范不同 Filter 不能够使用 Spring 容器资源 拦截器是一个Spring的组件，归Spring管理，配置在Spring文件中，因此能使用Spring里的任何资源、对象，例如 Service对象、数据源、事务管理等，通过IoC注入到拦截器即可 spring中使用Interceptor Filter 是被 Server(like Tomcat) 调用 Interceptor 是被 Spring 调用 Filter总优先于Interceptor执行 拦截器（Interceptor）和过滤器（Filter）的执行顺序过滤前-拦截前-Action处理-拦截后-过滤后 拦截器（Interceptor）使用interceptor 的执行顺序大致为： 请求到达 DispatcherServlet. DispatcherServlet 发送至 Interceptor ，执行 preHandle. 请求达到 Controller. 请求结束后，postHandle 执行.Spring 中主要通过 HandlerInterceptor 接口来实现请求的拦截，实现 HandlerInterceptor 接口需要实现下面三个方法： preHandle() – 在handler执行之前，返回 boolean 值，true 表示继续执行，false 为停止执行并返回。 postHandle() – 在handler执行之后, 可以在返回之前对返回的结果进行修改 afterCompletion() – 在请求完全结束后调用，可以用来统计请求耗时等等统计请求耗时：12345678910111213141516171819202122232425262728293031323334353637383940414243import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.log4j.Logger;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;public class ExecuteTimeInterceptor extends HandlerInterceptorAdapter&#123; private static final Logger logger = Logger.getLogger(ExecuteTimeInterceptor.class); //before the actual handler will be executed public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; long startTime = System.currentTimeMillis(); request.setAttribute(&quot;startTime&quot;, startTime); return true; &#125; //after the handler is executed public void postHandle( HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; long startTime = (Long)request.getAttribute(&quot;startTime&quot;); long endTime = System.currentTimeMillis(); long executeTime = endTime - startTime; //modified the exisitng modelAndView modelAndView.addObject(&quot;executeTime&quot;,executeTime); //log it if(logger.isDebugEnabled())&#123; logger.debug(&quot;[&quot; + handler + &quot;] executeTime : &quot; + executeTime + &quot;ms&quot;); &#125; &#125;&#125; 过滤器（Filter）使用Servlet 的 Filter 接口需要实现如下方法： void init(FilterConfig paramFilterConfig) – 当容器初始化 Filter 时调用，该方法在 Filter 的生命周期只会被调用一次，一般在该方法中初始化一些资源，FilterConfig 是容器提供给 Filter 的初始化参数，在该方法中可以抛出 ServletException 。init 方法必须执行成功，否则 Filter 可能不起作用，出现以下两种情况时，web 容器中 Filter 可能无效： 1）抛出 ServletException 2）超过 web 容器定义的执行时间。 doFilter(ServletRequest paramServletRequest, ServletResponse paramServletResponse, FilterChain paramFilterChain) – Web容器每一次请求都会调用该方法。该方法将容器的请求和响应作为参数传递进来， FilterChain 用来调用下一个 Filter。 void destroy() – 当容器销毁 Filter 实例时调用该方法，可以在方法中销毁资源，该方法在 Filter 的生命周期只会被调用一次。FrequencyLimitFilter com.company.filter.FrequencyLimitFilter FrequencyLimitFilter &#x2F;login&#x2F;* 拦截器（Interceptor）和过滤器（Filter）的一些用途 Authentication Filters Logging and Auditing Filters Image conversion Filters Data compression Filters Encryption Filters Tokenizing Filters Filters that trigger resource access events XSL&#x2F;T filters Mime-type chain Filter Request Filters 可以: 执行安全检查 perform security checks 格式化请求头和主体 reformat request headers or bodies 审查或者记录日志 audit or log requests 根据请求内容授权或者限制用户访问 Authentication-Blocking requests based on user identity. 根据请求频率限制用户访问 Response Filters 可以: 压缩响应内容,比如让下载的内容更小 Compress the response stream 追加或者修改响应 append or alter the response stream 创建或者整体修改响应 create a different response altogether 根据地方不同修改响应内容 Localization-Targeting the request and response to a particular locale.","tags":["spring"],"categories":["spring"]},{"title":"hexo 基本使用","path":"/2019/09/20/hexo-基本使用/","content":"hexo 基本使用1. 新建仓库新建一个github 仓库，仓库名必须是.github.io 格式，其中 是你 github 的昵称。 2. 全局安装hexo1$ npm install -g hexo 3. 初始化项目新建目录，在新建目录下，执行 hexo init ，就会自动构建一个 hexo 项目，紧接着执行 hexo s，浏览器访问 localhost:4000 就可以看到效果。 1234$ cd dir$ hexo init// 本地运行$ hexo s 4. 部署到github在项目根目录下找到 _congif.yml，找到 deploy 字段并填写完整。 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;你的仓库地址&gt; # git@github.com:benkang-chen/benkang-chen.github.io.git branch: master 推送到仓库需要安装一个额外的工具。 1$ npm install hexo-deployer-git --save 部署 12$ hexo clean$ hexo deploy 5. 查看效果访问自己的github io 地址即可查看到效果。 6. 新建文章1234// [layout] 为布局，可选项为 `post`、`page`、`draft`，这将决定文章所在文件路径。// &lt;title&gt; 为文章标题// 如 hexo new post 除了帅气，我还有啥！$ hexo new [layout] &lt;title&gt; 在 source&#x2F;post找到新建文章的md文档，可添加tags， categories 123tags: - hexocategories: hexo 7. 创建标签与分类页创建标签页 1$ hexo new page tags 配置标签页，在source下找到对应的tags目录，配置index.md文档 123title: tagsdate: 2019-09-20 17:43:47type: &quot;tags&quot; 配置分类页，在source下找到对应的categories目录，配置index.md文档 123title: categoriesdate: 2019-09-20 17:44:07type: &quot;categories&quot; 8. 部署发布新文档12$ hexo g$ hexo d 9. 删除文章删除文章，直接删除md文档，但要保证至少有一个md文件。然后执行 hexo clean.","tags":["hexo"],"categories":["hexo"]}]